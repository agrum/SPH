#version 140

in float vIndex;
flat in float clicIgnite;

uniform sampler3D bucketTexMap; 
uniform sampler1D physicalTexMap;
uniform sampler1D dttTexMap;
uniform sampler1D positionTexMap;
uniform int worldSize;
uniform float nbrParticle;

out vec4 dtt;

void main(){
	//Compute velocity
	vec3 P = vec3(0.0f,0.0f,0.0f);
	vec3 V = vec3(0.0f,0.0f,0.0f);
	vec3 G = vec3(0.0f,0.0f,0.0f);
	float m_density = 0;
	float eps = 0.00002;
	float ATMP = 0.9;
	float PI = 3.14159265358979323846264;
	float coefD = 315.0/(64.0*PI);
	float coefT = (2.0*3.0*27.0)/(4.0*4.0*107.0);
	vec3 m_position = texture(positionTexMap, vIndex).xyz * float(worldSize);
	float m_type = texture(dttTexMap, vIndex).b;
	float m_temperature = texture(dttTexMap, vIndex).g*0.75;
	float m_typeIndex = (m_type == 0) ? 1.0/6.0 : (m_type > 0.5) ? 5.0/6.0 : 1.0/2.0;
	bool ignite = false;
	
	
	vec3 baseIndex = (vec3(ivec3(m_position)) + vec3(0.5, 0.5, 0.5))/float(worldSize);
	
	//Density
	for(int i=-1;i<2;i++){ 
		for(int j=-1;j<2;j++){
			for(int k=-1;k<2;k++){
				vec3 offset = vec3(i,j,k)/float(worldSize);
				vec3 index = baseIndex + offset;
				if(clamp(index, vec3(0,0,0), vec3(0.9999,0.9999,0.9999)) == index){
					vec4 indice = texture(bucketTexMap, index);
					float indices[4]= float[4](indice.x,indice.y,indice.z,indice.w);
					for(int l = 0; l < 4 && indices[l] != 0; l++){
						indices[l] = (indices[l]*65536 - 0.5)/nbrParticle;
						if(abs(indices[l] - vIndex) > eps){
							vec3 p_position = texture(positionTexMap, indices[l]).xyz * float(worldSize);
							vec3 diff = (m_position - p_position) * 100;
							float sqDist = dot(diff, diff);
							if(sqDist < 10000.0){
								float dist = sqrt(sqDist)*0.01;
								float p_type = texture(dttTexMap, indices[l]).b;
								float p_temperature = texture(dttTexMap, indices[l]).g;
								float p_typeIndex = (p_type == 0) ? 1.0/6.0 : (p_type == 1) ? 5.0/6.0 : 1.0/2.0;
								float p_mass = texture(physicalTexMap, p_typeIndex).r;
								float tmpCoefD = pow(1.0 - dist*dist, 3);
								m_density += p_mass*coefD*tmpCoefD;
								m_temperature += 1 - dist;
								if(p_type > 0.1 && p_type < 0.5 && m_temperature > 0.8)
									ignite = true;
							}
						}
					}
				}
			}
		}	
	}
	
	m_temperature *= coefT;
	
	/*if(m_position.x < 2)
		m_density += (2.0 - m_position.x)*3.0;
	else if(m_position.x > worldSize-2)
		m_density += (m_position.x - (worldSize-2))*3.0;	
	if(m_position.y < 2)
		m_density += (2.0 - m_position.y)*3.0;
	else if(m_position.y > worldSize-2)
		m_density += (m_position.y - (worldSize-2))*3.0;	
	if(m_position.z < 2)
		m_density += (2.0 - m_position.z)*3.0;
	else if(m_position.z > worldSize-2)
		m_density += (m_position.z - (worldSize-2))*3.0;*/
		
	m_density += 1.0;
	
	if(m_type == 0 && m_density < 1.3 && ignite)
		m_type = 0.05f;
	else if (m_type > 0.5)
		m_type += 0.002;
	else if (m_type > 0.1){
		m_type += 0.006/m_density;
		m_temperature += (1.0 - m_type)*0.2;
	}
	
	dtt = vec4(m_density*0.01, m_temperature, m_type, 1);
}

