/*
 * CIFParticleObj.cpp
 *
 *  Created on: Jun 1, 2012
 *      Author: agrum
 */

#include "CIFParticleObj.h"

CIFParticleObj::CIFParticleObj(int p_worldSize):
m_nbrParticle(16384),
m_worldSize(p_worldSize),
m_activeParticle(m_nbrParticle),
m_textures(new GLfloat[m_nbrParticle*2]),
m_indices(new GLuint[m_nbrParticle]),
m_indexes(new GLuint[m_nbrParticle]),
m_positionA("position", 4, GL_RGBA16, GL_RGBA, GL_FLOAT),
m_positionB("position", 4, GL_RGBA16, GL_RGBA, GL_FLOAT),
m_velocityA("velocity", 5, GL_RGBA16, GL_RGBA, GL_FLOAT),
m_velocityB("velocity", 5, GL_RGBA16, GL_RGBA, GL_FLOAT),
m_A(false),
m_bucket("bucket", 7, GL_RGBA16, GL_RGBA, GL_UNSIGNED_SHORT),
m_densTempTypeA("dtt", 6, GL_RGB16, GL_RGB, GL_FLOAT),
m_densTempTypeB("dtt", 6, GL_RGB16, GL_RGB, GL_FLOAT),
m_physical("physical", 2, GL_RGB16, GL_RGB, GL_FLOAT),
m_spriteF("fire", 1, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE),
m_spriteW("water", 2, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE),
m_spriteS("smoke", 3, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE),
m_textCoords(new QVector2D[m_nbrParticle]),
m_expand(false),
m_infrared(false)
{
	//Shaders
	m_dttComputation.initProgram("shaders/particle/dttComputation");
	m_velocityUpdate.initProgram("shaders/particle/velocityUpdate");
	m_positionUpdate.initProgram("shaders/particle/positionUpdate");

	//Texture sizes
	m_bucket.setWidth(m_worldSize);
	m_bucket.setHeight(m_worldSize);
	m_bucket.setDepth(m_worldSize);
	m_densTempTypeA.setWidth(m_nbrParticle);
	m_densTempTypeB.setWidth(m_nbrParticle);
	m_velocityA.setWidth(m_nbrParticle);
	m_velocityB.setWidth(m_nbrParticle);
	m_positionA.setWidth(m_nbrParticle);
	m_positionB.setWidth(m_nbrParticle);

	//fboGen
	glGenFramebuffers(1, &m_fboId);

	//dtt texture
	void* bloh = calloc(m_nbrParticle*3, sizeof(float));
	m_densTempTypeB.setData(bloh);
	free(bloh);

	//Physical texture
	m_physical.setWidth(3);
	float physicalP[9];
	physicalP[0] = 1.0; //mass liquid
	physicalP[3] = 0.2; //mass fire
	physicalP[6] = 0.4; //mass smoke
	physicalP[1] = 0.4; //viscosity liquid
	physicalP[4] = 0.1; //viscosity fire
	physicalP[7] = 0.4; //viscosity smoke
	physicalP[2] = 0.995; //friction liquid
	physicalP[5] = 0.99; //friction fire
	physicalP[8] = 0.96; //friction smoke
	m_physical.setData(physicalP);

	//Point sprite texture
	glBindTexture(GL_TEXTURE_2D, m_spriteF.id());
	glTexEnvi(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE);
	glBindTexture(GL_TEXTURE_2D, 0);
	m_spriteF.appendImg("texture/fire.jpg");
	glBindTexture(GL_TEXTURE_2D, m_spriteW.id());
	glTexEnvi(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE);
	glBindTexture(GL_TEXTURE_2D, 0);
	m_spriteW.appendImg("texture/water.jpg");
	glBindTexture(GL_TEXTURE_2D, m_spriteS.id());
	glTexEnvi(GL_POINT_SPRITE_ARB, GL_COORD_REPLACE_ARB, GL_TRUE);
	glBindTexture(GL_TEXTURE_2D, 0);
	m_spriteS.appendImg("texture/smoke.png");

	//Particle initialization
	GLfloat velocities[m_nbrParticle*4];
	GLfloat positions[m_nbrParticle*4];
	GLfloat dtts[m_nbrParticle*3];

	for(int a = 0; a < m_nbrParticle; a++){
		m_indexes[a] = a;
		m_indices[a] = a;
		m_textCoords[a] = QVector2D(qrand()%800 + 100, qrand()%800 + 100);
		positions[a*4+0] = 0;
		positions[a*4+1] = 0;
		positions[a*4+2] = 0;
		velocities[a*4+0] = 0.5;
		velocities[a*4+1] = 0.5;
		velocities[a*4+2] = 0.5;
		dtts[a*3+0] = 0;
		dtts[a*3+1] = 0;
		dtts[a*3+2] = 0;
	}
	m_positionA.setData(positions);
	m_positionB.setData(positions);
	m_velocityA.setData(velocities);
	m_velocityB.setData(velocities);
	m_densTempTypeA.setData(dtts);
	m_densTempTypeB.setData(dtts);
}

CIFParticleObj::~CIFParticleObj(){
	glDeleteFramebuffers(1, &m_fboId);
}

void CIFParticleObj::add(const CMVP* p_camera, float p_x, float p_y){
	const QMatrix4x4 camView = p_camera->viewMatrix();
	const QMatrix4x4 camProj = p_camera->projMatrix();
	const QMatrix4x4 modelView = camView * m_modelMatrix;
	const QMatrix4x4 modelViewProj = camProj * modelView;
	const QMatrix4x4 invMVP = modelViewProj.transposed().inverted();

	QVector3D start, end;

	bool done = false;
	for(int a = 0; a < 500 && !done; a++){
		QVector4D bleh = QVector4D(p_x*2.0 - 1.0, (1.0 - p_y)*2.0 - 1.0, 1.0 - (float)a/250.0, 1) * invMVP;
		end = bleh.toVector3DAffine()/(float) m_worldSize;
		if(end.x() < 1 && end.x() > 0 &&
				end.y() < 1 && end.y() > 0 &&
				end.z() < 1 && end.z() > 0){
			done = true;
		}
		else{
			start = end;
		}
	}
	if(done){
		QVector3D position;
		QVector3D velocity;
		if(start.x() < 0){
			float ratio = (0.0 - start.x())/(end.x() - start.x());
			position = QVector3D(0.01 , start.y() + (end.y() - start.y())*ratio, start.z() + (end.z() - start.z())*ratio);
			velocity = QVector3D(0.001, 0, 0);
		}
		else if(start.x() > 1){
			float ratio = (1.0 - start.x())/(end.x() - start.x());
			position = QVector3D(0.99, start.y() + (end.y() - start.y())*ratio, start.z() + (end.z() - start.z())*ratio);
			velocity = QVector3D(-0.001, 0, 0);
		}
		else if(start.y() < 0){
			float ratio = (0.0 - start.y())/(end.y() - start.y());
			position = QVector3D(start.x() + (end.x() - start.x())*ratio, 0.01, start.z() + (end.z() - start.z())*ratio);
			velocity = QVector3D(0, 0.001, 0);
		}
		else if(start.y() > 1){
			float ratio = (1.0 - start.y())/(end.y() - start.y());
			position = QVector3D(start.x() + (end.x() - start.x())*ratio, 0.99, start.z() + (end.z() - start.z())*ratio);
			velocity = QVector3D(0, -0.001, 0);
		}
		else if(start.z() < 0){
			float ratio = (0.0 - start.z())/(end.z() - start.z());
			position = QVector3D(start.x() + (end.x() - start.x())*ratio, start.y() + (end.y() - start.y())*ratio, 0.01);
			velocity = QVector3D(0, 0, 0.001);
		}
		else if(start.z() > 1){
			float ratio = (1.0 - start.z())/(end.z() - start.z());
			position = QVector3D(start.x() + (end.x() - start.x())*ratio, start.y() + (end.y() - start.y())*ratio, 0.99);
			velocity = QVector3D(0, 0, -0.001);
		}

		QList<QVector3D> pending;
		pending.push_back(position);
		pending.push_back(velocity + QVector3D(0.5,0.5,0.5));
		pending.push_back(QVector3D(0,0,0));
		m_pendingParticles.push_back(pending);
	}
}

void CIFParticleObj::drop(){
	QVector3D ref(qrand()%798 + 101, qrand()%798 + 101, qrand()%398 + 501);
	QVector3D velocity(0.5,0.5,0.5);
	ref /= 1000.0;

	for(int a = -3; a <= 3; a++){
		for(int b = -3; b <= 3; b++){
			for(int c = -3; c <= 3; c++){
				QVector3D tmp(a, b, c);
				if(tmp.lengthSquared() <= 9){
					QList<QVector3D> pending;
					pending.push_back(ref + tmp/30.0);
					pending.push_back(velocity);
					pending.push_back(QVector3D(0,0,0));
					m_pendingParticles.push_back(pending);
				}
			}
		}
	}
}

void CIFParticleObj::ignite(){
	bool done = false;

	GLfloat dtts[m_nbrParticle*3];
	glBindTexture(GL_TEXTURE_1D, (m_A ? m_densTempTypeA : m_densTempTypeB).id());
	glGetTexImage(GL_TEXTURE_1D, 0, GL_RGB, GL_FLOAT, dtts);

	for(int a = 0; a < m_nbrParticle && !done; a++){
		if(dtts[3*a+0] < 1.3 && dtts[3*a+2] == 0){
			dtts[3*a+2] = 0.05;
			done = true;
		}
	}


	(m_A ? m_densTempTypeA : m_densTempTypeB).setData(dtts);
}

void CIFParticleObj::infrared(){
	m_infrared = !m_infrared;
}

QList<QVector4D> CIFParticleObj::getLights(){
	int lightCount = 0;
	QList<QVector4D> rtn;

	GLfloat positions[m_nbrParticle*4];
	glBindTexture(GL_TEXTURE_1D, (m_A ? m_positionA : m_positionB).id());
	glGetTexImage(GL_TEXTURE_1D, 0, GL_RGBA, GL_FLOAT, positions);
	GLfloat dtts[m_nbrParticle*3];
	glBindTexture(GL_TEXTURE_1D, (m_A ? m_densTempTypeA : m_densTempTypeB).id());
	glGetTexImage(GL_TEXTURE_1D, 0, GL_RGB, GL_FLOAT, dtts);

	for(int a = 0; a < m_nbrParticle && lightCount < 20; a++){
		if(dtts[a*3+0]*100.0 > 2.0 && dtts[a*3+2] > 0 && dtts[a*3+2] < 0.5){
			QVector4D tmp(positions[a*4+0], positions[a*4+1], positions[a*4+2], 0);
			tmp *= m_worldSize;
			tmp -= QVector4D((float)m_worldSize*0.5, (float)m_worldSize*0.5, (float)m_worldSize*0.5, 0);
			tmp.setW((dtts[a*3+0]*100.0 - 2.0)*0.1);
			rtn.push_back(tmp);
		}
	}

	return rtn;
}


void CIFParticleObj::iterate(){
	glBindFramebuffer(GL_FRAMEBUFFER, m_fboId);

	computeDTT();
	updateVelocity();
	updatePosition();
	m_A = !m_A;

	glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void CIFParticleObj::computeDTT(){
	//Choose texture
	CTexture& input = m_A ? m_densTempTypeA : m_densTempTypeB;
	CTexture& output = m_A ? m_densTempTypeB : m_densTempTypeA;

	//Clear
	glFramebufferTexture1D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_1D, output.id(), 0);
	glViewport(0, 0, m_nbrParticle, 1);
	glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	//Program
	m_dttComputation.use();

	//Get locations
	GLuint indexLoc = glGetAttribLocation(CProgram::currentId(),"index");
	glVertexAttribPointer(indexLoc , 1, GL_UNSIGNED_INT, GL_FALSE, 0, m_indexes);

	//Send textures
	m_bucket.sendToProgram();
	(m_A ? m_positionA : m_positionB).sendToProgram();
	input.sendToProgram();
	m_physical.sendToProgram();
	CProgram::current()->sendUniform1i("worldSize", m_worldSize);
	CProgram::current()->sendUniform1f("nbrParticle", m_nbrParticle);

	//Draw
	glEnableVertexAttribArray(indexLoc);
	glDrawElements( GL_POINTS, m_activeParticle, GL_UNSIGNED_INT, m_indices );
	glDisableVertexAttribArray(indexLoc);
}

void CIFParticleObj::updateVelocity(){
	//Choose texture
	CTexture& input = m_A ? m_velocityA : m_velocityB;
	CTexture& output = m_A ? m_velocityB : m_velocityA;

	//Clear
	glFramebufferTexture1D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_1D, output.id(), 0);
	glViewport(0, 0, m_nbrParticle, 1);
	glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	//Program
	m_velocityUpdate.use();

	//Get locations
	GLuint indexLoc = glGetAttribLocation(CProgram::currentId(),"index");
	glVertexAttribPointer(indexLoc , 1, GL_UNSIGNED_INT, GL_FALSE, 0, m_indexes);

	//Send textures
	m_bucket.sendToProgram();
	(m_A ? m_densTempTypeB : m_densTempTypeA).sendToProgram();
	(m_A ? m_positionA : m_positionB).sendToProgram();
	input.sendToProgram();
	m_physical.sendToProgram();
	CProgram::current()->sendUniform1i("worldSize", m_worldSize);
	CProgram::current()->sendUniform1f("nbrParticle", m_nbrParticle);

	//Draw
	glEnableVertexAttribArray(indexLoc);
	glDrawElements( GL_POINTS, m_activeParticle, GL_UNSIGNED_INT, m_indices );
	glDisableVertexAttribArray(indexLoc);
}
void CIFParticleObj::updatePosition(){
	//Choose texture
	CTexture& input = m_A ? m_positionA : m_positionB;
	CTexture& output = m_A ? m_positionB : m_positionA;

	//Clear
	glFramebufferTexture1D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_1D, output.id(), 0);
	glViewport(0, 0, m_nbrParticle, 1);

	//Program
	m_positionUpdate.use();

	//Get locations
	GLuint indexLoc = glGetAttribLocation(CProgram::currentId(),"index");
	glVertexAttribPointer(indexLoc , 1, GL_UNSIGNED_INT, GL_FALSE, 0, m_indexes);

	//Send textures
	input.sendToProgram();
	(m_A ? m_velocityB : m_velocityA).sendToProgram(); //channel 5
	CProgram::current()->sendUniform1i("worldSize", m_worldSize);
	CProgram::current()->sendUniform1f("nbrParticle", m_nbrParticle);

	//Draw
	glEnableVertexAttribArray(indexLoc);
	glDrawElements( GL_POINTS, m_activeParticle, GL_UNSIGNED_INT, m_indices );
	glDisableVertexAttribArray(indexLoc);
}

void CIFParticleObj::order(const QMatrix4x4& p_mvp){
	QList<int> bucket;
	int cube = m_worldSize*m_worldSize*m_worldSize;
	int x, y, z;
	int indice;

	QMap<double, GLuint> map;
	QMap<double, GLuint>::const_iterator ite;

	//Reinit
	unsigned short* bucketP = (unsigned short*) calloc(cube*4, sizeof(unsigned short));
	for(int a = 0; a < cube; a++)
		bucket.push_back(0);
	m_activeParticle = 0;

	GLfloat positions[m_nbrParticle*4];
	glBindTexture(GL_TEXTURE_1D, (m_A ? m_positionA : m_positionB).id());
	glGetTexImage(GL_TEXTURE_1D, 0, GL_RGBA, GL_FLOAT, positions);
	GLfloat velocities[m_nbrParticle*4];
	glBindTexture(GL_TEXTURE_1D, (m_A ? m_velocityA : m_velocityB).id());
	glGetTexImage(GL_TEXTURE_1D, 0, GL_RGBA, GL_FLOAT, velocities);
	GLfloat dtts[m_nbrParticle*3];
	glBindTexture(GL_TEXTURE_1D, (m_A ? m_densTempTypeA : m_densTempTypeB).id());
	glGetTexImage(GL_TEXTURE_1D, 0, GL_RGB, GL_FLOAT, dtts);
	for(int a = 0; a < m_nbrParticle; a++){
		QVector3D tmpP(positions[a*4+0], positions[a*4+1], positions[a*4+2]);
		tmpP *= m_worldSize;
		if(dtts[a*3+2] == 1.0){
			positions[a*4+0] = 0;
			positions[a*4+1] = 0;
			positions[a*4+2] = 0;
			dtts[a*3+1] = 0;
			dtts[a*3+2] = 0;

			tmpP= QVector3D(0,0,0);
		}
		if(tmpP.isNull() && !m_pendingParticles.empty()){
			QList<QVector3D> pending = m_pendingParticles.takeFirst();
			QVector3D pendingPosition = pending[0];
			QVector3D pendingVelocity = pending[1];
			QVector3D pendingDtt = pending[2];
			positions[a*4+0] = pendingPosition.x();
			positions[a*4+1] = pendingPosition.y();
			positions[a*4+2] = pendingPosition.z();
			velocities[a*4+0] = pendingVelocity.x();
			velocities[a*4+1] = pendingVelocity.y();
			velocities[a*4+2] = pendingVelocity.z();
			dtts[a*3+0] = pendingDtt.x();
			dtts[a*3+1] = pendingDtt.y();
			dtts[a*3+2] = pendingDtt.z();

			tmpP = pendingPosition*m_worldSize;
		}
		if(!tmpP.isNull()){
			QVector4D tmpQ = tmpP.toVector4D();
			tmpQ.setW(1);
			tmpQ = p_mvp * tmpQ;
			map.insertMulti(-(tmpQ.z()/tmpQ.w()), a);

			if(dtts[a*3+2] > 0 && dtts[a*3+2] < 0.08){
				dtts[a*3+2] += 0.11;
				QList<QVector3D> pending;
				pending.push_back(QVector3D(positions[a*4+0], positions[a*4+1], positions[a*4+2]));
				pending.push_back(QVector3D(velocities[a*4+0] + (float)(qrand()%100)/100000.0, velocities[a*4+1] + (float)(qrand()%100)/100000.0, velocities[a*4+2] + (float)(qrand()%100)/100000.0));
				pending.push_back(QVector3D(0,0,0.11));
				m_pendingParticles.push_back(pending);
			}

			QVector2D tmpV = (m_textCoords[a] - QVector2D(500,500))*0.01;
			m_textCoords[a] -= QVector2D(-tmpV.y(),tmpV.x());
			m_textCoords[a] -= tmpV*0.05;
			m_textures[a*2+0] = m_textCoords[a].x()*0.001;
			m_textures[a*2+1] = m_textCoords[a].y()*0.001;
			m_activeParticle++;

			x = tmpP.x();
			y = tmpP.y();
			z = tmpP.z();
			if(x == m_worldSize)
				x--;
			if(y == m_worldSize)
				y--;
			if(z == m_worldSize)
				z--;
			indice = x + y*m_worldSize + z*m_worldSize*m_worldSize;
			if(bucket[indice] < 4){
				bucketP[indice*4 + bucket[indice]] = a+1;
				bucket[indice]++;
			}
		}
	}
	m_pendingParticles.clear();

	int b = 0;
	for(ite = map.constBegin(); ite != map.constEnd(); ite++){
		m_indices[b] = ite.value();
		b++;
	}

	//Affect
	(m_A ? m_velocityA : m_velocityB).setData(velocities);
	(m_A ? m_positionA : m_positionB).setData(positions);
	(m_A ? m_positionB : m_positionA).setData(positions);
	(m_A ? m_densTempTypeA : m_densTempTypeB).setData(dtts);
	(m_A ? m_densTempTypeB : m_densTempTypeA).setData(dtts);
	m_bucket.setData(bucketP);
	free(bucketP);
}

void CIFParticleObj::drawSub(){
	//Get locations
	GLuint texLoc = glGetAttribLocation(CProgram::currentId(),"textureCoords");
	GLuint indexLoc = glGetAttribLocation(CProgram::currentId(),"index");
	glVertexAttribPointer(texLoc , 2, GL_FLOAT, GL_FALSE, 0, m_textures );
	glVertexAttribPointer(indexLoc , 1, GL_UNSIGNED_INT, GL_FALSE, 0, m_indexes);

	//Send textures
	m_spriteF.sendToProgram();
	m_spriteW.sendToProgram();
	m_spriteS.sendToProgram();
	(m_A ? m_densTempTypeA : m_densTempTypeB).sendToProgram();
	(m_A ? m_positionA : m_positionB).sendToProgram();
	(m_A ? m_velocityA : m_velocityB).sendToProgram(); //channel 5
	CProgram::current()->sendUniform1i("expand", (m_expand) ? 1 : 0);
	CProgram::current()->sendUniform1f("nbrParticle", m_nbrParticle);
	CProgram::current()->sendUniform1i("worldSize", m_worldSize);
	CProgram::current()->sendUniform1i("infrared", m_infrared ? 1 : 0);

	//Draw
	glEnableVertexAttribArray(indexLoc);
	glEnableVertexAttribArray(texLoc);
	glDrawElements(GL_POINTS, m_activeParticle, GL_UNSIGNED_INT, m_indices);
	glDisableVertexAttribArray(indexLoc);
	glDisableVertexAttribArray(texLoc);
}
